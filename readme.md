# Конспект по книге Рамальо Лучано - Python. К вершинам мастерства - 2016 
## Глава 1.
### Были рассмотрены:
#### [Карточная игра](chapter1/cards.py)
* namedtuple из библиотеки Collections
* Списковые включения (list comprehension) (Приведен пример как из 2ух списков получить все возможные комбинации)
* Магические методы __len__(), __getitem__(), __init__() (Приведен пример как сделать класс итерируемым)
* key в виде функции в методе sorted()
* Создание словаля (dict) с помощью конструктора
#### [Класс для работы с векторами](chapter1/vectors.py)
* Магический метод __repr__() (Как альтернатива __str__())
* Метод hypot из библиотеки math. (hypot(x,y) = sqrt(x*x + y*y))
* Методы bool и abs
* Магические методы __abs__(), __bool__(), __add__(), __mul__() (переопределены)
## Глава 2.
### Были рассмотрены:
#### [Работа с numpy](chapter2/arr_numpy.py)
* Создание массива. 
* Изменение формы массива. 
* Получение элемента массива по индексу. 
* Транспортирование массива (изменить местами строки и столбцы). 
* Сохранение и загрузка массива из файла *.npy 
* Умножение/деление/сложение/вычитание всех элементов массива на n
#### [Работа с array из библиотеки array](chapter2/arr_numpy.py)
* Создание большого массива (только одинаковые типы данных (typecode)) при помощи генератора
* Запись массива в [.bin файл](chapter2/floats.bin) и чтение из файла
#### [Работа с deque из библиотеки collections](chapter2/arr_numpy.py)
* Создание очереди фиксированной длины
* Добавление элементов слева (справа будут удалены)
* Добавление элементов справа (слева будут удалены)
* Циклический сдвиг
#### [Работа с генераторами](chapter2/generator_comprehension.py)
* Создание с помощью генератора массива, кортежа, списка
* Трактация каждого элемента как отдельного поля
* Распаковка с помощью фиктивной переменной
* Метод divmod(a,b) (возвращает кортеж: a // b, a % b)
* При передаче котрежа в качестве аргумента, * перед названием кортежа распаковывает кортеж. divmod(*t)
* Выборка лишних элементов с помощью * (a , *b , c = [1,2,3,4,5])
* Распаковка вложенных кортежей
* Именованные кортежи (метод _make(), метод _as_dict() (превращает объект в collections.OrderedDict))
#### [Работа со списками](chapter2/list_add.py)
* Магический метод __iadd__() (при сложении изменяемых объектов, ссылка останется прежней. Изменится сам объект)
* Магический метод __add__() (при сложении неизменяемых объектов, будет создан новый объект)
* Генерация списков из ссылок ссылающихся на один и тот же объект, и генерация списков из уникальных ссылок
#### [Работа со списковыми включениями](chapter2/list_comprehension.py)
* Замена filter + lambda с помощью list comprehension + if
* Изменение порядка упорядочивания элементов при генерации из 2 списков всех возможных комбинаций
#### [Сортировка списков](chapter2/list_sort.py)
* Метод .sort() (Изменяет исходный размер и возвращает None)
* Метод sorted() (Возвращает новый объект, не изменяя старый)
#### [Работа со срезами](chapter2/slice.py)
* Именованные срезы (slice(3,6))
* Именованные срезы, с одним аргументов (slice(None,6))
* Удаление среза
* Замена среза на произвольное колличество аргументов
## Глава 3.
### Были рассмотрены:
#### [Counter из библиотеки Collections](chapter3/collection_counter.py)
* Counter (принимает строку, разбивает на буквы. Возвращает словарь типа: бува : сколько раз встречается)
* Метод .update() добавляет к исходной строке ещё текста
* Метод .most_common(х) (выводит х самых часто встречающихся букв)
#### [DefaultDict из библиотеки Collections](chapter3/defaultdict.py)
* defaultfactory (Если заданного ключа нет, создаётся default_factory)
#### [Хешируемые и не хешируемые типы данных](chapter3/defaultdict.py)
* хешируемые = не изменяемые (если tuple не содержит ссылки на нехешируемые объекты)
* Любой пользовательский тип является хешируемым (его ID = хеш). Если реализован метод __eq__, объект будет хешируемым, если все его атрибуты не изменяемы
* OrderedDict - сохраняет порядок добавления элементов (в отличии от dict)
* 5 методов создать словарь (конструктор, присваивание ключу значения, из 2ух список с помощью zip, из списка кортежей, из словаря)
#### [Dict comprehension](chapter3/dict_comprehension.py)
* Создание словаря из списка котрежей
* Инвертация словаря (изменить местами ключ и значение)
#### [Dict default](chapter3/dict_search.py)
* dict.setdefault(key, default) (Получение элемента из словаря по ключу. Если такого ключа нет, создаётся значение по умолчанию)
* dict.setdefault(key, default) (Получение элемента из словаря по ключу. Если такого ключа нет, возвращается значение по умолчанию)
#### [MappingProxyType](chapter3/MappingProxyType_example.py)
* Неизменяемый словарь
* Любые изменения исходного отображения будут видны в MappingProxyType, но через него сделать изменения нельзя
#### [UserDict](chapter3/UserDict_example.py)
* UserDict хранит внутри себя экземпляр dict в атрибуте data (он не наследует dict)
* Можно переопределить магический метод __missing__() (срабатывает когда нет ключа в словаре)
* Метод isinstance (проверка типов)
#### [StrKeyDict](chapter3/str_key_dict.py)
* Словарь, унаследованный от dict
* Автоматически переводит значение ключа в str с помощью переопределённого магического метода __missing__()
#### [Множества](chapter3/sets.py)
* Метод intersection() (пересечение множеств)
* Синтаксис создания множеств
* frozenset (неизменяемые множества)
* set comprehension
* Объединение множеств
* Разность множеств
* Симметрическая разность множеств
* Пересечение множеств
* isdisjoint() (множества не пересекаются)
* .add(), .copy(), .clear(), .remove()
* .discard() удалить элмент, если он существует